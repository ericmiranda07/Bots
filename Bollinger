//+------------------------------------------------------------------+
//|                                                    Bollinger.mq5 |
//|                              Copyright 2023, Eric Miranda Britto |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2023, Eric Miranda Britto"
#property link      "https://www.mql5.com"
#property version   "1.00"

// Include Trade class
#include <Trade\Trade.mqh>
CTrade Trade;

//--- input parameters
 ulong    InpMagicNumber_bot1 = 212312365;
 
  double  pontos_entrada = 5.0;
  int BollingerPeriodBuy = 250;
  double BollingerDesvioBuy = 1.0;
 ENUM_TIMEFRAMES TimeFrameBollingerBuy = PERIOD_M30;
  int MinimaPeriodos = 20;
  
//--- input parameters
  
  ulong    InpMagicNumber_bot2 = 753986123;
  double  pontos_entrada_bot2 = 15;
  int BollingerPeriodBuy_bot2 = 350;
  double BollingerDesvioBuy_bot2 = 0.5;
  ENUM_TIMEFRAMES TimeFrameBollingerBuy_bot2 = PERIOD_H3;
  int MinimaPeriodos_bot2 = 15;
  double Percent_saida_sell = 1.0;
  
  

 double numContratos   = 0.01;    // Agora definido para 0.01 contratos

//--- indicator's handles
int bollingerHandle;
int bollingerHandle_bot2;
//--- global variables
datetime lastTradeTime = 0; // Tempo da última entrada de trade
datetime lastTradeTime_bot2 = 0; // Tempo da última entrada de trade
double min_0 = 0; //minima dos ultimos x periodos

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   // Initialize Bollinger Bands indicator
   bollingerHandle = iBands(_Symbol, TimeFrameBollingerBuy, BollingerPeriodBuy, 0, BollingerDesvioBuy, PRICE_LOW);
   if(bollingerHandle == INVALID_HANDLE)
     {
      Print("Invalid Bollinger Bands handle, error: ", GetLastError());
      return(INIT_FAILED);
     }
     
   bollingerHandle_bot2 = iBands(_Symbol, TimeFrameBollingerBuy_bot2, BollingerPeriodBuy_bot2, 0, BollingerDesvioBuy_bot2, PRICE_LOW);
   if(bollingerHandle_bot2 == INVALID_HANDLE)
     {
      Print("Invalid Bollinger Bands handle, error: ", GetLastError());
      return(INIT_FAILED);
     }  
   // Initialize trade object
   Trade.SetExpertMagicNumber(InpMagicNumber_bot1);
   
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
      Trade.SetExpertMagicNumber(InpMagicNumber_bot1);
      Bot_1();
      Trade.SetExpertMagicNumber(InpMagicNumber_bot2);
      Bot_2();
  }
//---
//+------------------------------------------------------------------+
//| Bot_1 buy                                                        |
//+------------------------------------------------------------------+
void Bot_1()
{
      datetime currentTime = TimeCurrent();
   
   // Verifica se já se passaram 30 minutos desde a última entrada
   if(currentTime >= lastTradeTime + 1800) // 1800 segundos = 30 minutos
     {
      // Obtém dados do candle anterior
      MqlRates rates[];
      ArraySetAsSeries(rates, true);
      int copied = CopyRates(_Symbol, TimeFrameBollingerBuy, 1, 1, rates);
      if(copied < 1)
        {
         Print("Failed to get candle data");
         return;
        }
      
      // Obtém o valor da Banda Inferior de Bollinger no candle anterior
      double BollingerLowerArray[];
      ArraySetAsSeries(BollingerLowerArray, true);
      int copiedBB = CopyBuffer(bollingerHandle, 2, 1, 1, BollingerLowerArray);
      if(copiedBB < 1)
        {
         Print("Failed to get Bollinger Band data");
         return;
        }
      
      // Verifica a condição de entrada
      if(rates[0].open < BollingerLowerArray[0] && rates[0].close > BollingerLowerArray[0])
        {
         // Condição de entrada atendida, procede para abrir posição de compra
         
         // Obtém a mínima das mínimas dos últimos 20 candles
         MqlRates rates20[];
         ArraySetAsSeries(rates20, true);
         int copied20 = CopyRates(_Symbol, TimeFrameBollingerBuy, 1, MinimaPeriodos, rates20);
         if(copied20 < 20)
           {
            Print("Failed to get last 20 candles data");
            return;
           }
         
         double minLow = rates20[0].low;
         for(int i = 1; i < MinimaPeriodos; i++)
           {
            if(rates20[i].low < minLow)
               minLow = rates20[i].low;
           }
         
         // Abre posição de compra com stop loss na mínima dos últimos 20 candles
         double price  = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double sl     = minLow;
         double tp     = 0; // Sem take profit definido
         double volume = numContratos; // Agora definido como 0.01
         string comment = "Bollinger Buy Entry";
         
         if( sl != min_0)
         {
            Trade.PositionOpen(_Symbol, ORDER_TYPE_BUY, volume, price, sl, tp, comment);
            min_0 = minLow;
         }
         
         
         
         // Atualiza o tempo da última entrada
         lastTradeTime = currentTime;
        }
     }
   
   // Para todas as posições abertas, verifica se o stop loss deve ser movido
   int totalPositions = PositionsTotal();
   for(int i = 0; i < totalPositions; i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
        {
         // Verifica se a posição é para o símbolo atual e tem o magic number correto
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && PositionGetInteger(POSITION_MAGIC) == InpMagicNumber_bot1)
           {
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(posType == POSITION_TYPE_BUY)
              {
               double entryPrice   = PositionGetDouble(POSITION_PRICE_OPEN);
               double sl           = PositionGetDouble(POSITION_SL);
               double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
               
               double valor_swap = ((SymbolInfoDouble(_Symbol,SYMBOL_SWAP_LONG))/100) * 3;
               
               double swap = PositionGetDouble(POSITION_SWAP);
               
               double swap_stop = 0;
               
               if(swap < valor_swap)
               {
                  Print("Fechar operacao com o ticket", ticket);
                  swap_stop = swap*-100;
               }
               
               // Calcula a diferença de preço
               
               double priceDifference = entryPrice - sl;
               double targetPrice     = entryPrice + priceDifference;
               double novo_stop       = entryPrice + pontos_entrada + swap_stop;
               
               if(currentPrice > targetPrice && sl != novo_stop)
                 {
                  // Move o stop loss para o preço de entrada
                  double tp = PositionGetDouble(POSITION_TP); // Mantém o take profit atual
                  Trade.PositionModify(ticket, entryPrice + pontos_entrada + swap_stop, tp);
                 }
              }
           }
        }
     }
}




//+------------------------------------------------------------------+
//| Função que retorna a soma dos volumes das posições de compra     |
//+------------------------------------------------------------------+
double GetTotalBuyVolume()
  {
   double totalBuyVolume = 0.0;
   int totalPositions = PositionsTotal();

   for(int i = 0; i < totalPositions; i++)
     {
      // Obtém o ticket da posição pelo índice
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
        {
         // Verifica se a posição é do símbolo atual e tem o tipo de compra
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY)
           {
            // Soma o volume da posição de compra
            totalBuyVolume += PositionGetDouble(POSITION_VOLUME);
           }
        }
     }
   return totalBuyVolume;
  }

//+------------------------------------------------------------------+
//| Bot_2 sell                                                       |
//+------------------------------------------------------------------+
void Bot_2()
{
      datetime currentTime = TimeCurrent();
   
   // Verifica se já se passaram 30 minutos desde a última entrada
   if(currentTime >= lastTradeTime_bot2 + 1800) // 1800 segundos = 30 minutos
     {
      // Obtém dados do candle anterior
      MqlRates rates[];
      ArraySetAsSeries(rates, true);
      int copied = CopyRates(_Symbol, TimeFrameBollingerBuy_bot2, 1, 1, rates);
      if(copied < 1)
        {
         Print("Failed to get candle data");
         return;
        }
      
      // Obtém o valor da Banda Inferior de Bollinger no candle anterior
      double BollingerLowerArray[];
      ArraySetAsSeries(BollingerLowerArray, true);
      int copiedBB = CopyBuffer(bollingerHandle_bot2, 2, 1, 1, BollingerLowerArray);
      if(copiedBB < 1)
        {
         Print("Failed to get Bollinger Band data");
         return;
        }
      
      // Verifica a condição de entrada
      if(rates[0].open > BollingerLowerArray[0] && rates[0].close < BollingerLowerArray[0])
        {
         // Condição de entrada atendida, procede para abrir posição de compra
         
         // Obtém a mínima das mínimas dos últimos 20 candles
         MqlRates rates20[];
         ArraySetAsSeries(rates20, true);
         int copied20 = CopyRates(_Symbol, TimeFrameBollingerBuy_bot2, 1, MinimaPeriodos_bot2, rates20);
         if(copied20 < MinimaPeriodos_bot2)
           {
            Print("Failed to get last 20 candles data");
            return;
           }
         
         double minLow = rates20[0].high;
         for(int i = 1; i < MinimaPeriodos_bot2; i++)
           {
            if(rates20[i].high > minLow)
               minLow = rates20[i].high;
           }
         
         // Abre posição de compra com stop loss na mínima dos últimos 20 candles
         double price  = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         double sl     = minLow;
         double tp     = price - ((price/100)*Percent_saida_sell); // Sem take profit definido
         double volume = numContratos; // Agora definido como 0.01
         string comment = "Bollinger Sell Entry";
         double totalBuyVolume = GetTotalBuyVolume();
         
         if( sl != min_0)
         {
            Trade.PositionOpen(_Symbol, ORDER_TYPE_SELL, totalBuyVolume, price, sl, tp, comment);
            min_0 = minLow;
         }
         
         
         
         // Atualiza o tempo da última entrada
         lastTradeTime_bot2 = currentTime;
        }
     }
   
   // Para todas as posições abertas, verifica se o stop loss deve ser movido
   int totalPositions = PositionsTotal();
   for(int i = 0; i < totalPositions; i++)
     {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
        {
         // Verifica se a posição é para o símbolo atual e tem o magic number correto
         if(PositionGetString(POSITION_SYMBOL) == _Symbol && PositionGetInteger(POSITION_MAGIC) == InpMagicNumber_bot2)
           {
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(posType == POSITION_TYPE_BUY)
              {
               double entryPrice   = PositionGetDouble(POSITION_PRICE_OPEN);
               double sl           = PositionGetDouble(POSITION_SL);
               double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
               
               double valor_swap = ((SymbolInfoDouble(_Symbol,SYMBOL_SWAP_LONG))/100) * 3;
               
               double swap = PositionGetDouble(POSITION_SWAP);
               
               double swap_stop = 0;
               
               if(swap < valor_swap)
               {
                  Print("Fechar operacao com o ticket", ticket);
                  swap_stop = swap*-100;
               }
               
               // Calcula a diferença de preço
               
               double priceDifference = entryPrice - sl;
               double targetPrice     = entryPrice + priceDifference;
               
               if(currentPrice > targetPrice)
                 {
                  // Move o stop loss para o preço de entrada
                  double tp = PositionGetDouble(POSITION_TP); // Mantém o take profit atual
                  Trade.PositionModify(ticket, entryPrice - pontos_entrada - swap_stop, tp);
                 }
              }
           }
        }
     }
}
